---
title: Java内存区域介绍以及JDK1.8内存变化
date: 2023-05-19 13:30:48
permalink: /pages/8b1290/
---


# Java内存区域介绍以及JDK1.8内存变化

## 运行数据区域-->JDK1.8

### 1、程序计数器（Program Counter Register ）

> Java虚拟机在在执行Java程序的过程中会把他所管理的内存划分为若干个不同的数据。Java虚拟机所管理的内存将会包括以下几个运行时数据存储区域；

<img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220728195713848.png" alt="image-20220728195713848" style="zoom: 80%;" />

> 1. 程序计数器(Program CounterRegister) 是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里, 字节码解释器工作时就是通过改变这个计数器的值来选去下一跳需要执行的字节码指令, 分支, 循环, 跳转, 异常处理,线程恢复等基础功能都需要依赖这个计数器来完。
> 2. 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的, 在任何一个确定的时刻, 一个处理器(对于多核处理器来说是一个内核) 只会执行一条线程中的指令。 因此, 为了线程切换后能恢复到正确的执行位置, 每条线程都需要有一个独立的程序计数器, 各条线程之间的计数器互不影响, 独立存储, 我们称这类内存区域为"线程私有内存"。
> 3. 如果线程正在执行的是一个Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是Native方法, 这个计数器值则为空(Undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 2、Java虚拟机栈

> 1. 与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks) 也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型 ： 每个方法执行的时候都会创建一个`方法栈帧`，如下图用于存储 **局部变量表, 操作栈, 动态链接, 方法出口等信息**. 每一个方法被调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程.
> 2. **局部变量表**存放了编译器可知的各种**基本数据类型**（int ，short，long，byte，long，float，double，boolean，char），`对象引用`(reference类型, 它不等同于对象本身, 根据不同的虚拟机实现, 他可能是一个指向对象起始地址的引用指针, 也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和**returnAddress类型**(指向了一条字节码指令的地址)。
> 3. 其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot), 其余的数据类型只占用一个, 局部变量表所需的内存空间在编译期间完成分配, 当进入一个方法时, 这个方法需要在帧中分配多大的局部变量空间是完全确定的, 在方法运行期间不会改变局部变量表的大小。
> 4. 如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出StackOverflowError异常; 如果虚拟机栈可以动态扩展(当前大部分Java虚拟机都可动态拓展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),当拓展时无法申请到足够的内存时会抛出OutOfMemoryError异常。



![image-20220728195818861](https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220728195818861.png)



### 3、本地方法栈

本地方法栈和虚拟机栈发挥的作用十分相似。同样线程是私有的，他们之间的区别是**Java虚拟机为Java方法服务，而本地方法栈为虚拟机使用的Native方法服务。**在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。与虚拟机栈一样，本地方法栈也会抛出**StackOverflowError** 异常和**OutOfMemoryError** 异常。

### 4、Java堆

![image-20220728200926419](https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20220728200926419.png)

### 5、方法区

> 1. 方法区（Method Aera）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的信息，常量，静态变量，即编译器和变异后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分, 但是它却有一个别名叫做Non-Heap非堆, 目的应该是与Java Heap 区分开来。
> 2. 在**JDK1.7**之前HotSpot虚拟机使用永久代来实现方法区，永久代的大小在启动JVM时可以设置一个固定值（-**XX:MaxPermSize**），不可变；
> 3. 在JDK1.7中 存储在永久代的部分数据就已经转移到Java Heap或者Native memory。譬如符号引用(Symbols)转移到了native memory，原本存放在永久代的字符常量池移出。但永久代仍存在于JDK 1.7中，并没有完全移除。
> 4. JDK1.8中进行了较大改动
>    1. 移除了永久代（PermGen），替换云空间（MetaSpace）。
>    2. 永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；
>    3. 永久代中的 interned Strings 和 class static variables 转移到了 Java heap；
>    4. 永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）

### 6、常量池

> 1. 运行时常量池(Runtime Constant Pool) 是方法区的一部分(虚拟机规范)。 Class文件中除了有类的版本, 字段,方法, 接口等描述信息外, 还有一项信息是常量池(Constant Pool Table), 用于存放编译期生成的各种字面量和符号引用, 这部分内容将在类加载后存放到方法区的运行时常中。
> 2. 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性, Java语言并不要求常量一定只能在编译期产生, 也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池, 运行期间也可能将新的常量放入池中, 这种特性被开发人员利用的比较多的便是String类的intern() 方法。

### 7、直接内存

> 1. 在JDK1.4 中新加入的NIO 类，引入了一种基于通道（Channel）和缓冲区（Buffer）的I/O 形式，他可以使用Native 函数直接分配堆外内存，然后通过一个存储在Java 堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场所显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。
> 2. 直接内存(Direct Memory) 并不是虚拟机运行时数据区的一部分, 也不是Java虚拟机规范中定义的内存区域, 但是这部分内存也被频繁地使用, 而且也可能导致OutOfMemoryError异常出现。 显然, 本机直接内存的分配不会受到Java堆大小的限制, 但是, 既然是内存, 则肯定还是会受到本机总内存的大小及处理器寻址空间的限制。 服务器管理员配置虚拟机参数时, 一般会根据实际内存-Xmx等参数信息, 但经常会忽略到直接内存, 使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制), 从而导致动态扩展时出现OutOfMemoryError异常。